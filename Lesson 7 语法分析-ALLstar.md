ANTLR 4 使用了这种算法 Adaptive LL(\*)

![[Pasted image 20260212201402.png]]
妙啊
如何防止递归的时候把加法变成右结合：优先级上升 climbing
![[Pasted image 20260212203421.png]]
因为 `+, *` 都是左结合的运算符，所以递归调用时优先级都要升一级
![[Pasted image 20260212203521.png]]
![[Pasted image 20260212203614.png]]
括号匹配压根不是左递归，放入基础情况中即可，再调用 expr, 由于置于括号内，所以优先级从头开始算起，也就是 0.

相应地，如果是右结合的运算符，优先级参数不再上升：
![[Pasted image 20260212203849.png]]
再考虑前缀、后缀运算符：
前缀运算符本质是右结合的，所以需要优先级上升；
后缀运算符本质是左结合的，所以不能优先级上升；
下面的 ! 有点特殊，因为后面不跟东西了，也就无所谓递归调用或者优先级上不上升了。
![[Pasted image 20260212204048.png]]
![[Pasted image 20260212204117.png]]
![[Pasted image 20260212205222.png]]
ALLstar 算法思路：构建一个 DFA，读取任意多个字符，最终走到一个接收状态，这个接收状态会告诉你应该选择第几条规则进行展开。
![[Pasted image 20260212205717.png]]
问题来了，如何构建这个 DFA ？

并行探索：
![[Pasted image 20260212210430.png]]
