![[Pasted image 20260214182454.png]]
![[Pasted image 20260214182615.png]]

@ 全局符号；% 局部符号
![[Pasted image 20260214233100.png]]
`%` 变量可以看成虚拟寄存器，可以有无穷多个。
![[Pasted image 20260215001207.png]]
zext：zero extension 零扩展

两个关键概念：
![[Pasted image 20260215010544.png]]
1. 三地址码

操作数1，操作数2，结果保存在哪里

2. 静态单赋值

单赋值：每个虚拟寄存器只能被赋值一次（只能在等号左边出现 1 次）
静态：？

控制流图
![[Pasted image 20260215011016.png]]
![[Pasted image 20260215011618.png]]
例子：递归实现阶乘 factorial
（感觉已经非常接近 ida 里看到的汇编语句了）
![[Pasted image 20260215013720.png]]
注意 %2 的作用：不管走哪条路，都把结果放进 %2 指示的空间里去，这样最后返回结果的时候直接返回这个地方的值就行了。
细节：跳转指令不能在基本块内部，但 call 指令可以。
![[Pasted image 20260215014547.png]]
神奇 phi 指令：如果从 %1 跳转过来，则返回 1，如果从 %3 跳转过来，则返回 %6 中的内容，结果给 %8.
事实上汇编代码没有跟 phi 指令相对应的指令，可以认为这是个“虚拟指令”，要在后端解决这个指令。但是在中间代码阶段 phi 指令可以使代码更加简洁。
![[Pasted image 20260215014924.png]]
例子：循环实现阶乘 factorial
![[Pasted image 20260215015234.png]]
开启优化：
![[Pasted image 20260215015849.png]]
